The Diamond Problem happens in multiple inheritance — when a class inherits from two classes that both come from the same parent class.
Class D gets two copies of class A — one from B and one from C.
This causes confusion and duplication.

B and C now share one common A because of virtual inheritance.
When D is created:
The compiler ensures only one A is built (shared).
The most derived class (D) is responsible for constructing A.
Then B and C constructors run, using that same A.
So A’s constructor runs only once, not twice.




#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "A constructor\n"; }
    void show() { cout << "Hello from A\n"; }
};

class B : public A {
public:
    B() { cout << "B constructor\n"; }
};

class C : public A {
public:
    C() { cout << "C constructor\n"; }
};

class D : public B, public C {
public:
    D() { cout << "D constructor\n"; }
};

int main() {
    cout << "\n--- Diamond Problem (Without Virtual) ---\n";
    D obj;
    // obj.show();  // ❌ Ambiguous — compiler doesn’t know from B’s A or C’s A
    obj.B::show();  // ✅ Explicitly call via B’s A
    obj.C::show();  // ✅ Explicitly call via C’s A
    cout << "Two A objects exist (one from B and one from C)\n";
    return 0;
}



# -----------------------------------------------------------
# Example 2: With Virtual Inheritance (Solution)
# -----------------------------------------------------------
cat > diamond_solution.cpp <<'EOF'
#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "A constructor\n"; }
    void show() { cout << "Hello from A\n"; }
};

class B : virtual public A {
public:
    B() { cout << "B constructor\n"; }
};

class C : virtual public A {
public:
    C() { cout << "C constructor\n"; }
};

class D : public B, public C {
public:
    D() { cout << "D constructor\n"; }
};

int main() {
    cout << "\n--- Diamond Problem Solved (With Virtual) ---\n";
    D obj;
    obj.show();  // ✅ Works fine — only one shared A
    cout << "Only one A object exists (shared between B and C)\n";
    return 0;
}
