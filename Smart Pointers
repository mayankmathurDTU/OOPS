smart pointers came in cpp 11

+---------+------+-----------------------------------------------+
| Version | Year | Key Highlights                                |
+---------+------+-----------------------------------------------+
| C++11   | 2011 | auto, lambdas, smart pointers, threads        |
| C++14   | 2014 | generic lambdas, make_unique, return deduction|
| C++17   | 2017 | optional, variant, filesystem, bindings       |
| C++20   | 2020 | concepts, ranges, coroutines, modules, <=>    |
| C++23   | 2024 | expected, print, flat_map, refinements        |
| C++26   | ~2026| pattern matching, reflection, networking      |
+---------+------+-----------------------------------------------+


-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <memory>   // needed for smart pointers
using namespace std;

int main() {
    // ---------- unique_ptr ----------
    unique_ptr<int> uptr1 = make_unique<int>(10);  // create unique_ptr owning value 10
    cout << "unique_ptr value: " << *uptr1 << endl;

    // unique_ptr cannot be copied → only moved
    unique_ptr<int> uptr2 = move(uptr1);           // transfer ownership from uptr1 to uptr2
    if (!uptr1) cout << "uptr1 is now null (ownership moved)\n";
    cout << "uptr2 value: " << *uptr2 << endl;

    // ---------- shared_ptr ----------
    shared_ptr<int> sptr1 = make_shared<int>(20);  // create shared_ptr owning 20
    shared_ptr<int> sptr2 = sptr1;                 // another shared_ptr to same object
    cout << "shared_ptr count after copy: " << sptr1.use_count() << endl; // 2 owners
    cout << "shared_ptr value: " << *sptr1 << endl;

    {
        shared_ptr<int> sptr3 = sptr2;             // one more shared_ptr in new scope
        cout << "shared_ptr count inside block: " << sptr1.use_count() << endl; // 3
    }                                              // sptr3 destroyed → count decreases
    cout << "shared_ptr count after block: " << sptr1.use_count() << endl; // 2 owners now

    // ---------- weak_ptr ----------
    weak_ptr<int> wptr = sptr1;                    // weak_ptr observes shared_ptr (no ownership)
    cout << "weak_ptr created (does not increase count)\n";
    cout << "shared_ptr count: " << sptr1.use_count() << endl; // still 2

    // to use weak_ptr, lock() it to get a temporary shared_ptr
    if (auto temp = wptr.lock()) {                 // lock returns shared_ptr if object still exists
        cout << "weak_ptr locked, value: " << *temp << endl;
    } else {
        cout << "object already deleted" << endl;
    }

    // when all shared_ptr go out of scope, object is deleted
    sptr1.reset();                                 // release one owner
    sptr2.reset();                                 // release second owner
    cout << "All shared_ptr released, object destroyed.\n";

    if (wptr.expired())                            // check if object still exists
        cout << "weak_ptr now expired.\n";

    return 0;
}
